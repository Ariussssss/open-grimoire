#+STARTUP: content
* Design Patterns (设计模式)
** Principle SOLID 原则
   前五个为 SOLID 面向对象的五个基本原则
*** 单一职责原则 SRP Single Responsibility Principle
*** 开放封闭原则 OCP Open Close Principle
    类，模块，函数可拓展，应该尽量不可修改。
*** 里氏替换原则 LSP Liskov Substitution Principle
    引用类的地方，必须可以透明的替换成其子类。
*** 接口隔离原则 ISP Interface Segregation Principle
    尽量最小化，细化接口，
    接口的方法单一。
*** 依赖倒置原则 DIP Dependence Inversion Principle
    保持可拓展性（依赖和动态参数的转化，抽象化）
    - 高层模块不依赖底层模块
    - 细节依赖抽象，抽象不依赖细节
*** 迪米特原则 LD Law of Demeter
    最少知识原则。
    降低对其依赖的了解，依赖关系低，降低耦合性。

** Patterns
*** Abstract Factory 抽象工厂
    创建模式

    抽象成都从低到高分为，简单工厂模式，工厂模式，抽象工厂模式。

    通过参数生成一个，或者多个相关或者相互依赖的对象，不需要指定类。
    这样保留了可拓展性，只需要新建类不需要修改，符合开闭原则。
    更新新的元素也不需要修改工厂和接口。
   
    适用于更新元素和需求符合基础特点的系统，保证尽量不需要修改工厂。
    而且新的元素不仅仅是只需更新单个，还需要对应已有的参数进行其他实体的补充，满足整体性和可以相互依赖。
    假如已有 10 种风格的地图，要增加陷阱地形，就要先预设 10 种。其他条件叠加计算。

*** Builder 生成器
    创建模式

    分离复杂对象构建流程，
    将过程步骤抽象，通过参数或者其他方式动态控制

    例子：根据不同内容，装填成不同的罐头

    如果对象只有一种表示，不需要太多 set 操作的时候没必要复杂化。
*** Factory Method 工厂方法
    创建模式

    简单来说就是利用函数创建对象，而不是 new
*** Prototype 原型模式
    创建模式

    每个实例暴露一个 ~clone~ 接口。
    特点是允许运行时创建实例，基于已有的实例进行创建。
    可以保持运行无感，创建替换新的实例。

    可以配合工厂方法使用，接受实例返回 ~clone~ 新实例。

    不足：
    1. 需要重写 ~clone~ ，对类的实现由侵入，违背开闭原则
    2. 调用深拷贝较麻烦，整体链路也会很长
*** Singleton 单例模式
    创建模式。

    保证一定范围内唯一，主要是后端，保证资源时间段内（如请求内）独享。
    类提供获取单例方式（请求时生成，懒汉型），
    或者直接在创建的时候（初始化生成，饿汉型）检索是否存在。

    不足：
    - 对封装，继承，多态支持不好
    - 有理解成本，需要知道是引用还是创建的。
    - 可拓展性不好，多例转化可能很困难
    - 测试麻烦，需要每次还原

    例子：数据库链接池，Redux 数据库，游戏共享物品
*** Adapter 适配器模式
    结构性模式

    又名 ~wrapper~ 。
    指将一个类的接口，转换为另一个期望的接口。
    磨平接口不兼容的问题，
    在不对原有对象改造的前提想，构造一个适配器完成模块衔接。

    不足：
    1. 每次重构或者更新系统，改造成本较高
    2. 使用的每个第三方包都需要检查适配
    3. 新旧 API 兼容

    例子：多种插头处理，数据库 ORM 兼容，window/unix 兼容。
*** Bridge 桥接模式
    结构模式。

    抽象部分与它的实现部分分离，使他们可以独立的变化。

    类似适配器模式，不过是从插座端做接口控制。
    在接口层分成，调用层（抽象）和实现层。
    调用层调用实现底层提供的接口，暴露不变的功能接口。
    做到抽象层和实现层的分离，同时暴露两者接口，满足不同场景的自由组合。

    精髓在于抽离最底层的统一功能，开发给未来需要的可拓功能。

    例子：汽车生产线改造新能源生产线。
*** Flyweight 享元模式
    类似于单例模式的抽象实现

    思想是对于内存大或者不需要变化的公共元素保持单例模式

    外部抽象实现其地址引用和可变公共参数（如别名，获取日期等）

    例子：网盘云存储，大型多人游戏，IDE 字符

    优点是节省内部状态存储，尽可能共享对象，使用引用。

    不适用于细粒度对象不多的场景。

    如英文文档，26 个字母 1 万字优化是 10000:26，中文去重后也有 3000，则优化比例是 10000:3000

*** Proxy 代理模式
    简单来说，提供一种代理，控制对象的访问

    如： Vue，Angular 等监听对象的访问机制

    适合的场景：
    - 对于开销大的对象代理，实现按需使用
    - 对于需要保护的对象进行代理，权限控制
    - 在对象访问与修改时执行一些逻辑，适合在代理层做
*** Chain of Responsibility 职责链模式
    属于行为型模式，不仅描述对象和类的模式，还包含一种通信模式，处理传递。

    单个行为沿着链传递，每个行为对象检验和执行自己的操作（复杂的 if else）。
    好处是可以使多个对象有机会处理请求，避免发送和接受者的耦合。
    例子：中间件（Koa 的洋葱模型），不同模块的通用帮助文案，JS 事件冒泡机制

    弊端：中间件之前必须互相信任，顺序需要保证，不能保证不同中间件调用的可靠性。
    只适合不确定是否调用的处理对象，需要灵活应对的的场景。
*** Command 命令模式
    将请求封装成对象，按顺序很进度进行下一步调度，允许排队，重试，可撤销，日志记录等。

    例子：餐厅服务员，浏览器请求，大型桌面系统的菜单。

    优点：
    - 可以控制流程进行和存储，任意时刻调用。
    - 排队，记录日志，撤销和重做得以实现。

    弊端：
    - 仅记录操作。
    - 记录全量快照。
    - 共享内存。

    即没有撤销重做的大部分场景，都没必要做成这个模式。
    而且还需要控制协同编程造成的冲突，以及快照过大的问题。
*** Interpreter 解释器模式
    行为模式。
    非终结符和终结符都继承抽象表达式，非终结符后继续接表达式。

    一种思维，将复杂语法解析抽象成一个个单独独立的终结符，非终结符进行各自判断。
    交给文法自己判断，然后组装文法。
    有点像 职责链模式，功能拆分，整体结构化联系到一起。

    例子：各语言解析器。
** Model
*** 生产者消费者
    并发设计, 分 input channel, output channel

    可以通过 channel 长度控制并发, 尝试获取等待
