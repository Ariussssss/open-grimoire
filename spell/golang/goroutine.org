#+STARTUP: content
#+CREATED: [2021-05-18 11:02]
* goroutine
** Refer
   - https://mp.weixin.qq.com/s/r0y4Fweq-YGo1FZrsNsl3A
   - https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a
   - https://codeburst.io/why-goroutines-are-not-lightweight-threads-7c460c1f155f
   - https://mp.weixin.qq.com/s/_Tl1cGTdPxwSF1ctHc1yZg
   - https://web.archive.org/web/20160128221609/https://air.unipr.it/retrieve/handle/11381/2297671/6288/camp2000.pdf
   - https://mp.weixin.qq.com/s?__biz=MjM5MDUwNTQwMQ==&mid=2257485825&idx=1&sn=daae56d68d8b418d90f64161c24c6ce8&chksm=a539e0d7924e69c177f7c8eb6ad596354c09019afff2358e5dc1666487ddccb80140f639c68e&cur_album_id=1690026440752168967&scene=189#rd
   - https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/
** æ¦‚å¿µ
   #+begin_quote
   Each goroutine (G) runs on an OS thread (M) that is assigned to a logical CPU (P).

   G - goroutine.
   M - çº¿ç¨‹, æˆ–è€…æœºå™¨. 
   P - æ‰§è¡Œç”¨çš„è¿›ç¨‹, M å¿…é¡»ä¾é ä¸€ä¸ª P æ¥æ‰§è¡Œ G.
   #+end_quote

   Go é¦–å…ˆæ ¹æ®æœºå™¨ç‰©ç† GPU æ•°é‡, åˆ›å»ºè¿›ç¨‹, å­˜å‚¨åˆ°ä¸€ä¸ªé—²ç½®çš„åˆ—è¡¨é‡Œé¢.  
   æ–°çš„ goroutine ç”Ÿæˆä¼šå”¤èµ·ä¸€ä¸ªé—²ç½®çš„è¿›ç¨‹å»æ‰§è¡Œ, è¿›ç¨‹ä¼šåˆ›å»ºä¸€ä¸ªå¸¦çº¿ç¨‹çš„ ~M~.
   å…¶ä¸­æ“ä½œç³»ç»Ÿçš„çº¿ç¨‹æœ€å¤§æ•°é‡ä¸º ~GOMAXPROCS~ ä¸ª. 
   æ²¡æœ‰ goroutine è¿è¡Œçš„, æˆ–è€…è¢« GC å¼ºåˆ¶åœæ­¢çš„ ~P~, ~M~ ä¼šå›åˆ°é—²ç½®é˜Ÿåˆ—.  

   å½“ goroutine åˆ›å»ºæ—¶:
   1. æ£€ç´¢å½“å‰ ~P~ æ˜¯å¦èƒ½ç”¨æ¥æ‰§è¡Œ
   2. æŸ¥çœ‹æ˜¯å¦æœ‰é—²ç½®çš„ ~P~ ç”¨æ¥æ‰§è¡Œ
   3. å°† goroutine æŒ‚åˆ°å…¨å±€é˜Ÿåˆ—é‡Œé¢, å¹¶ä¸”å½’è¿˜æ‰€é™„å±çš„ ~M~

   åƒ ~http.Get~ è¿™ç§æƒ…å†µ, å½“å‰ ~G0~ ä¼šç­‰å¾… http æ„å»ºçš„ ~G1~ è¿”å›ç»“æœä¸”åœæ­¢æ‰§è¡Œ.  
   è¿™ä¸ªæ—¶å€™å½“å‰ ~P~ å’Œ ~M~ éƒ½é—²ç½®, å¯ä»¥ç”¨æ¥æ‰§è¡Œæ–°æ„å»ºçš„ ~G1~ ä¸éœ€è¦é‡æ–°æ„å»º.  
   ç­‰å¾…æ‰§è¡Œå®Œæˆå, é‡Šæ”¾å½“å‰ ~P~ å’Œ ~M~ å½’è¿˜ç»™ä¹‹å‰çš„ç­‰å¾… ~G0~ ç»§ç»­æ‰§è¡Œ.  
** å¯¹æ¯”çº¿ç¨‹
   çº¿ç¨‹æ…¢çš„åŸå› (å¯ä»¥ä¼˜åŒ–çš„éƒ¨åˆ†):
   1. çº¿ç¨‹éœ€è¦æ¶ˆè€—ä»–ä»¬æ ˆå¤§å°çš„å†…å­˜, æœ€å°‘ 1MB. 
   2. çº¿ç¨‹æ³¨å†Œéœ€è¦å¾ˆå¤šåˆå§‹åŒ–å·¥å…·,å½±å“æ€§èƒ½, åƒ:
      - AVX( Advanced vector extension)
      - SSE (Streaming SIMD Ext.) æˆ–è€… MMX
      - Floating Point registers
      - Program Counter (PC)
      - Stack Pointer (SP)
   3. å¯åŠ¨å’Œæ³¨é”€éœ€è¦ç³»ç»Ÿåˆ†é…èµ„æº, éœ€è¦è°ƒåº¦æ“ä½œç³»ç»Ÿå°±ä¼šæ…¢

   ç›¸æ¯”:
   1. è€Œ goroutines æ˜¯å­˜åœ¨äº go è¿è¡Œæ—¶åˆ†é…çš„è™šæ‹Ÿç©ºé—´é‡Œé¢è€Œéæ“ä½œç³»ç»Ÿä¸­.
      æ‰€ä»¥è°ƒåº¦è°ƒåº¦ä¹Ÿæ˜¯é€šè¿‡ go è¿è¡Œæ—¶æ¥å®Œæˆ.
   2. goroutine åˆå§‹åŒ–åªéœ€è¦ 2KB æ ˆå¤§å°.
      ä¸éœ€è¦çš„æ ˆä¼šè¢«å†…å­˜äºŒæ¬¡æœç”¨, å‡å°å†…å­˜æŸè€—.
   3. goroutine é˜»å¡ä¸ç­‰äºçº¿ç¨‹é˜»å¡ ~M~, ä¸Šé¢æœ‰ğŸ‘†.
   4. goroutine é—²ç½®æˆ–è€… block ä¸åŒäºæ‰“æ–­.
      å—è°ƒåº¦å™¨ç®¡ç†, å½“å†æ¬¡æ¢å¤æ—¶åªéœ€è¦ PC, SP, DX (Data Register) ä¸éœ€è¦æ›´å¤šåˆå§‹åŒ–æµç¨‹. 
** è°ƒåº¦
   åˆ†ä¸‰çº§è¿è¡Œé˜Ÿåˆ—:
   - ~runnext~
     æ¥å—ä¸‹ä¸€ä¸ª ~G~, ä»…ä¸€ä¸ªå¤§å°çš„æ•°ç»„, å¦‚æœæœ‰åˆ™æŒ‰é¡ºåºæ’åˆ° ~local queue~
   - ~local queue~
     å¤§å° 256 çš„æ•°ç»„, æ»¡åˆ™åˆ†ä¸€åŠåˆ° ~global queue~ ç»™å…¶ä»– ~P~ æ¶ˆè´¹. 
   - ~global queue~

   #+begin_src go
     package main

     import (
	 "fmt"
	 "runtime"
     )

     func main() {
	 runtime.GOMAXPROCS(1)
	 for i := 0; i < 10; i++ {
	     i := i
	     go func() {
		 fmt.Println(i)
	     }()
	 }

	 var ch = make(chan int)
	 <-ch
     }
     // 9
     // 0
     // 1
     // 2
     // 3
     // 4
     // 5
     // 6
     // 7
     // 8
     // fatal error: all goroutines are asleep - deadlock!

     // goroutine 1 [chan receive]:
     // main.main()
     //         /Users/arius/lib/go-test/goroutime-sort.go:18 +0x96
     // exit status 2
   #+end_src
   ç”¨ ~channel~ é”æ­»ç­‰å¾…è¶…æ—¶.  
   æ¯ä¸€ä¸ªæ–°ç”Ÿæˆçš„ ~G~ ä¼šæŠ¢å  ~runnext~ , è¢«æŠ¢å çš„ ~G~ ä¼šåœ¨æŒ‰ ~FIFO~ é¡ºåºè¿›å…¥ ~load queue~.

   PS: 1.14 å‰ ~time~ åŒ…ä¼šæœ‰ä¸€ä¸ª ~timerproc~ çš„ ~G~ æŠ¢å  ~runnext~.
   æ‰€ä»¥ç›´æ¥è°ƒ ~time.Sleep~ å¯¼è‡´æ¬¡åºä¸ä¸€è‡´.
   
*** history
    - å•çº¿ç¨‹è°ƒåº¦å™¨ 0.x
      - G-M æ¨¡å‹
    - å¤šçº¿ç¨‹è°ƒåº¦å™¨ 1.0
      - å…è®¸å¤šçº¿ç¨‹, å…¨å±€é”ç«äº‰
    - ä»»åŠ¡çªƒå–è°ƒåº¦å™¨ 1.1
      - å¼•å…¥ P, å‡ºç° G-M-Pæ¨¡å‹
      - Goroutine ç­‰å¾…ä¸ä¼šè®©å‡ºçº¿ç¨‹
      - STW è¶…é•¿
    - æŠ¢å å¼è°ƒåº¦å™¨ 1.2 ~ è‡³ä»Š
      - åŸºäºåä½œ 1.2 ~ 1.13
	- åœ¨å‡½æ•°è°ƒç”¨æ—¶æ’å…¥æŠ¢å æ£€æŸ¥æŒ‡ä»¤, åˆ¤æ–­æŒ¡å¢™ Goroutine æ˜¯å¦å¯ç”¨
	- STW è¶…çº§é•¿å¯¼è‡´ç¨‹åºæš‚åœ
      - åŸºäºä¿¡å· 1.14 ~ è‡³ä»Š
	- åŸºäºä¿¡å·çš„çœŸæŠ¢å è°ƒåº¦
	- åƒåœ¾å›æ”¶æ‰«ææ ˆè§¦å‘è°ƒåº¦
	- æ—¶é—´ç‚¹ä¸å¤š, ä¸èƒ½è¦†ç›–æ‰€æœ‰è¾¹ç¼˜
*** å•çº¿ç¨‹è°ƒåº¦
    40 è¡Œä»£ç :
    1. è·å–å…¨å±€é”
    2. ~gosave~ ä¿å­˜æ ˆå¯„å­˜å™¨å’Œç¨‹åºè®¡æ•°å™¨
    3. ~nextgandunlock~ è·å–ä¸‹ä¸€ä¸ªéœ€è¦è¿è¡Œçš„ Gorotine è§£é”è°ƒåº¦å™¨
    4. ä¿®æ”¹ m ä¸Šæ‰§è¡Œçš„ Goroutine
    5. è°ƒç”¨ ~gogo~ è¿è¡Œæœ€æ–°çš„ Goroutine
       
    #+begin_src c
      static void scheduler(void) {
	  G* gp;
	  lock(&sched);

	  if(gosave(&m->sched)){
	      lock(&sched);
	      gp = m->curg;
	      switch(gp->status){
	      case Grunnable:
	      case Grunning:
		  gp->status = Grunnable;
		  gput(gp);
		  break;
	      ...
	      }
	      notewakeup(&gp->stopped);
	  }

	  gp = nextgandunlock();
	  noteclear(&gp->stopped);
	  gp->status = Grunning;
	  m->curg = gp;
	  g = gp;
	  gogo(&gp->sched);
      }
    #+end_src
*** å¤šçº¿ç¨‹è°ƒåº¦
    å’Œä¹‹å‰å·®ä¸å¤š, å¢åŠ  ~GOMAXPROCS~ ç®¡ç†æœ€å¤§å¤„ç†å™¨æ•°

    é—®é¢˜:
    1. è°ƒåº¦å™¨å’Œé”æ˜¯å…¨å±€èµ„æº, ä¸­å¿ƒåŒ–ç®¡ç†
    2. çº¿ç¨‹ä¹‹é—´éœ€è¦ä¼ é€’ Goroutine, å»¶è¿Ÿ
    3. æ¯ä¸ªçº¿ç¨‹éœ€è¦å¤„ç†å†…å­˜ç¼“å­˜
    4. ç³»ç»Ÿé¢‘ç¹é˜»å¡å’Œé‡Šæ”¾çº¿ç¨‹
*** ä»»åŠ¡çªƒå–
    - å¼•å…¥ P, å¢åŠ ä¸­é—´å±‚
    - å®ç°å·¥ä½œçªƒå–çš„è°ƒåº¦å™¨

    æµç¨‹:
    1. å¦‚æœåœ¨è¿è¡Œæ—¶ç­‰å¾…åƒåœ¾å›æ”¶, åˆ™è°ƒç”¨ ~gcstopm~
    2. ä»å½“å‰å¤„ç†å™¨æˆ–è€…å…¶ä»–å¤„ç†å™¨è·å– Goroutine
    3. æ‰§è¡Œ
*** æŠ¢å å¼
    ä¹‹å‰ Goroutine éœ€è¦ä¸»åŠ¨è®©å‡º CPU èµ„æºæ‰èƒ½è§¦å‘è°ƒåº¦, é€ æˆé—®é¢˜:
    - æŸäº› G é•¿æ—¶é—´å ç”¨, å…¶ä»– G é¥¥é¥¿
    - STW æš‚åœæ•´ä¸ªç¨‹åº, æœ€é•¿å¯èƒ½è¦å‡ åˆ†é’Ÿ
**** åä½œå¼
     STW æ£€æŸ¥  Goroutine è¿è¡Œæ˜¯å¦è¶…è¿‡ 10ms ä¼šè¢«æ ‡è®°. 
     åœ¨å‡½æ•°æ‰§è¡Œå‰, ä¼šè¢«ç¼–è¯‘æ’å…¥ ~morestack~. 
     åœ¨æ‰§è¡Œæ—¶, è°ƒç”¨ ~newStack~ æ£€æŸ¥ Goroutine æ˜¯å¦è¢«æ ‡è®°, ç„¶åæŠ¢å . 
**** ä¿¡å·å¼
     ç‰¹ç‚¹:
     1. ä¿¡å·éœ€è¦è¢«è°ƒè¯•å™¨å·ç©¿
     2. ä¸ä¼šè¢«å†…éƒ¨ libc æ‹¦æˆªå’Œä½¿ç”¨
     3. å¯ä»¥å‡ºç°åœ¨ä»»æ„ä½ç½®ä¸”ä¸è§¦å‘åæœ
     4. å¤„ç†å¤šå¹³å°ä¸åŒä¿¡å·


     ç‰¹ç‚¹æ˜¯ STW å’Œ æ ˆæ‰«ææ˜¯å¯ä»¥è¢«æŠ¢å çš„.
     è§£å†³äº†è¿™ä¸¤ä¸ªä¸€ç›´å¡ä½ç¨‹åºçš„é—®é¢˜. 
** A goroutine cannot recover from a panic in another goroutine.
   #+begin_quote
   While executing a function F, an explicit call to panic or a run-time panic terminates the execution of F. 
   Any functions deferred by F are then executed as usual. 
   Next, any deferred functions run by F's caller are run, and so on up to any deferred by the top-level function in the executing goroutine. 
   At that point, the program is terminated and the error condition is reported, including the value of the argument to panic. 
   This termination sequence is called panicking.
   #+end_quote

** MORE

