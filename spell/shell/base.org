* Shell
** syntax
   参数
   #+begin_src shell
     echo "Shell 传递参数实例！";
     echo "执行的文件名：$0";
     echo "第一个参数为：$1";
     echo "第二个参数为：$2";
     echo "第三个参数为：$3";
     echo "参数个数为$#"
     echo "所有参数$@"
     echo "所有参数$*"
     echo "进程号$$"
   #+end_src

   判断
   #+begin_src shell
     if [ $a -le $b ]
     then
	echo "$a -le $b: a 小于或等于 b"
     else
	echo "$a -le $b: a 大于 b"
     fi
   #+end_src

   非空
   #+begin_src shell
     [ test -z "$word" ]
     [ ! -n "$word" ]
     [ ! "$word" ]
     [ "" = "$word" ]
   #+end_src
** spells
*** du

    Human-readable
    depth

    #+begin_src shell
      du -h -d 1 .
    #+end_src
    
** tools
*** cloc Count Lines of Code

    从 Draven blog 里看到的，统计词数
**  set -o allexport
   env 失效问题根源, 需要允许 env 相关 source 来源允许导出
** count
   #+begin_src shell
     grep -o "[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+" httpd.log | sort | uniq -c | sort -n
     cat demo.txt | awk '{print $2}' | sort | uniq -c | sort -n -r | head -n 1
   #+end_src
   
   awk '{ print $2}'：取数据的第2域（第2列），第一列是标号（1，2，3...）,第二列是ip地址

   sort：对IP部分进行排序。

   uniq -c：打印每一重复行出现的次数。（并去掉重复行）

   sort -n -r：按照重复行出现的次序倒序排列。

   head -n 1：取排在第一位的ip地址
** awk
   #+begin_src bash
     echo something | awk '{ print $1 }'
   #+end_src
** xargs
   #+begin_src bash
     xargs git branch -d < ./branch.txt
     awk | xargs kill -9
     # 参数
     ls -d ./* | xargs -i {} cp {} ~/tmp
   #+end_src
** find
   通配文件检索
   #+begin_src shell
     find ./**/*.org -type f
   #+end_src
** wc
   #+begin_src shell
     wc -wl
   #+end_src
** scp
   #+begin_src shell
     scp -P 2222 file.ext username@domain:~/ 
   #+end_src
** sed
   filter 获取
   #+begin_src shell
     git diff --name-only | sed -E '*.org'
   #+end_src
