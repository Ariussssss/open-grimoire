#+STARTUP: content
* rust-safity
** Safity
   安全是 Rust 的核心.
   类型安全, 类型系统保证程序行为是意义明确, 不出错的.
   诸多编程语言中, OCaml 和 Haskell 是公认的类型安全的典范.

   Rust 借鉴了他们的类型系统,保证类型安全, 尤其是 Haskell.

   此外还需要实现一套内存管理模型, 实现不会出现内存访问错误问题.

   内存访问错误源头:
   - 使用空指针.
   - 为初始化内存.
   - 释放后使用, 垂悬指针.
   - 缓冲区溢出, 如数组越界
   - 重复释放, 非法释放已经是释放的指针

   发生原因, 访问了未定义内存.
   Rust 的内存管理模型:
   - 借有和生命周期.
   - 所有权系统, 每个被分配的内存都有一个独占其所有权的指针.
     只有当该指针被销毁, 其对应内存才随之释放.
   - 变量有生命周期, 超出生命周期, 变量自动释放.
   - 借由: 可以通过标记生命周期参数 (注解) 供编译器检查的方式, 防止悬垂指针.
     释放后使用.

   所有权系统保障了可以安全管理内存不需要 GC, 借鉴了 C++ 的 RAII 机制.

   同时 rust 也通过关键字 ~unsafe~ 提供了非安全模式, 让用户可以自信的面向系统底层编程.
   如访问空指针:
   #+begin_src rust
     let mut num = 5;

     let r1 = &num as *const i32;
     let r2 = &mut num as *mut i32;

     unsafe {
	 println!("r1 is: {}", *r1);
	 println!("r2 is: {}", *r2);
     }
   #+end_src
   传入引用的时候, 清理的是引用, 而非原始值.

** 所有权
   基本规则:
   - Rust 中的每一个值都有一个被称为其使用者 Owner 的变量. 
   - 值在任一时刻有且只有一个所有者. 
   - 当所有者变量离开作用域, 值丢弃.
     
   ~let~ 声明变量不可对位置表达式赋值, 但是可以添加 ~mut~ 关键字, 或者重复 ~let~ 声明.
   重复声明表示重新定义一个变量, 复用变量名字.
   借用 ~Borrow~ 的关键字(就是取地址符号) ~&~, 意为在不转移的强况下获取内存地址.
   然后通过解引用 ~Deref~ 操作符 ~*~.

   对于指针变量(大部分复杂类型), 直接赋值或者作为函数参数会视为对内存的 所有权 ~Ownership~ 进行转移 ~Move~.
   ~More~ 有点像浅拷贝, 不同点就是原指针不能用了.
   ~Borrow~ 可以在作用域结束时归还, 而 ~More~ 不行. 

   #+begin_src rust
     fn main () {
	 // 和直接定义 a = "hello world"; 不同。
	 // 大小如果固定的话, 直接拷贝很迅速
	 let a = String::from("hello world");
	 let b = a;
	 // println!("a is {}", a); // 这里会编译失败, 提示：a value used here after move.
     }
   #+end_src
   
   PS: Rust 永远不会自动创建数据的深拷贝. 而 trait 有个特殊注解, 当一个类型拥有 ~Copy~ trait 在赋值时会保留原来的值可用. 

** Life time
*** 一般生命周期
   大部分时间 引用 都是有可推断的生命周期, 也是大多数语言的设定.
   Rust 在一部分场合可以主动管理引用变量, 也是与众不同的功能.

   ~{}~ 创建作用域, 内部作用域不能直接赋值给外部地址, 因为会回收. (垂悬指针)

   像 ~'static~ 指定静态生命周期可以让他一直活在程序里, 不同域会存活但是丢失引用(回收).
   新版本可以直接使用关键字 ~const~,  ~static~ 默认开启 ~'static~ 注解.
   
**** 引用
     一般来说变量会在词法作用域 ~{}~ 时结束生命周期, 也可以用这个开辟一个新的词法作用域.
     同时不可变引用和可变引用也不能在同一个域共存, 毕竟不可变引用用户不希望有人在它使用的时候值变了

     同时为了避免数据竞争 ~data race~ , 同一个值的引用在一个作用域只允许一个. 
   
     而离开作用域后, 作用域里的所有的变量都会被清理.
     像可变引用不可以在同一个域使用多次的引用的问题, 就可以不断开域.

     #+begin_src rust
       let mut s = String::from("hello");

       {
	   let r1 = &mut s;
	   ...
       }

       {
	   let r2 = &mut s;
	   ...
       }

       let r3 = &mut s;
     #+end_src
    
*** 泛型生命周期
    在泛型引用的时候可以通过注解的方式, 让两个引用共享同一个生命周期.

    #+begin_src rust
      fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
	  if x.len() > y.len() {
	      x
	  } else {
	      y
	  }
      }
    #+end_src
   
    其中 ~'a~ 在返回处声明了, 所以 ~x, y~ 的生命周期在返回之前都是生效的.
    即使运行时结果不一致, 短命的还是会等待长寿的活下来.
   
    而如果一个变量的声明是一个泛型的话, 其生命周期会与最短命的同步. 
    #+begin_src rust
      fn main() {
	  let string1 = String::from("long string is long");
	  let result;
	  {
	      let string2 = String::from("xyz");
	      result = longest(string1.as_str(), string2.as_str());
	  }
	  // println!("The longest string is {}", result);
	  // 报错: string2, borrowed value does not live long enough
      }
    #+end_src
    这里的 ~result~ 得到的值生命周期由 ~string1~ 和 ~string2~ 共享.
    之前在 ~longest~ 中, 泛型指定的周期持续到函数结束.
    之后的变量,生命周期由 ~string1~ 和 ~string2~ 最短命的决定, 除非再手动指定. 

*** 生命周期省略
    生命周期注解相当于, 主动维护生命周期.
    部分注解被官方发现重复度很高, 便对应识别自动生成生命周期, 于是有了 生命周期省略法则 lifetime elision rules:
    - 作为函数的参数, 是引用.
      会自动生成并带上一个对应的生命周期参数.
    - 如果只有一个输入的生命周期参数.
      其会被赋予所有输出的生命周期参数.
    - 如果有多个输入的生命周期参数, 且其中一个为 ~&self~ 或者 ~&mut self~.
      所有输出参数会被赋予 ~self~ 的生命周期

    第三条必须配合 ~impl~ 使用.
    #+begin_src rust
      struct A {
	  num: i32
      }

      impl A {
	  fn getNum(&self) -> i32 {
	      self.num
	  }
	  fn hi(&self) -> String {
	      String::from("hi")
	  }
      }

      fn main() {
	  let a = A {
	      num: 1
	  };
	  println!("{}", a.getNum());
	  println!("{}", a.hi());
      }
    #+end_src
    其中参数都因为规则一获取生命周期, 而返回值生命周期因为规则三自动绑定 ~self~.
    
** More
*** RAII Resource Acquisition Is Initialization
    RAII要求, 资源的有效期与持有资源的对象的生命期严格绑定, 即由对象的构造函数完成资源的分配（获取）, 同时由析构函数完成资源的释放.
    在这种要求下, 只要对象能正确地析构, 就不会出现资源泄露问题.
    
    是由 c++之父 Bjarne Stroustrup 提出的, 中文翻译为资源获取即初始化.
    他说：使用局部对象来管理资源的技术称为资源获取即初始化,.
    这里的资源主要是指操作系统中有限的东西如内存、网络套接字等等, 局部对象是指存储在栈的对象, 它的生命周期是由操作系统来管理的, 无需人工介入.

    C++ (如果不使用 RAII) 在使用类似 堆内存, 文件, sockets, mutexes 锁 等资源时, 先请求再使用.
    在函数结构使用完后, 需要对应的 ~delete~ 或者 ~release~.
    像出现 ~throw~ 或者其他情况返回也需要对应资源进行处理.
    规范不建议写 ~new~, ~delete~.
    应该用对象和方法管理内存.
    
    总结: 资源, 状态, 对象与生命周期绑定, 语言通过解析生命周期, 对状态和资源进行管理.

** Refers
   - https://mp.weixin.qq.com/s/lPbag5EbuWPUZOCvObW-yw
   - https://medium.com/swlh/what-is-raii-e016d00269f9
   - https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization
   - https://doc.rust-lang.org/rust-by-example/scope/raii.html
   - https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html

