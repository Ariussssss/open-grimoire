#+STARTUP: content
* Node 模块
** Refers
   - http://nodejs.cn/api/esm.html#esm_modules_ecmascript_modules
   - https://juejin.cn/post/6866973719634542606#heading-18
   - https://mp.weixin.qq.com/s/EzmNQ_oqxUuPQFfZYJWDzA
   - https://www.freecodecamp.org/news/requiring-modules-in-node-js-everything-you-need-to-know-e7fbd119be8/

** 模块解析
    Packages/node/lib/internal/modules/cjs/loader.js
     
    默认有 3 种 （v13 更新了第四种，还在实验），分别是 js，json，node。
    Node 默认使用 CommonJS 模式，即基础 js 解析模式，也是这里只涉及到的一个 js 解析模式。

    具体步骤大致如下：
    1. 查询对应文件的绝对路径
    2. 读取文件的类型
    3. 通过封装（套函数外壳）创建私有作用域。
    4. 通过 VM 读取，执行代码
    5. 完成加载后，对应绝对路径缓存代码
      
*** 关键模块
    Node 在模块解析上有两个关键全局模块，不需要加载来完成模块引用和解析的操作。
    
    - Require
    - Module

    可以理解成这样， ~require~ 做为的交互用指令， ~module~ 作为全部引用模块的管理者。
    依赖的引用就是通过两者的合作完成的。

*** 加载顺序

    1. 优先还在内置模块，如果有同名的会优先使用内置模块（像 ~require~ 和 ~module~ ）。
    2. 查询缓存
    3. 查询路径，判断文件和文件夹查询
    4. 报错

    第三部中的查询地址顺序可以通过打印 ~module~ 查看。
    这是 Node 模块解析时候的顺序和对应的路径。
    
    #+begin_src shell
    // console.log(module)
      Module {
	id: '.',
	path: '/Users/arius/Lib/node-test',
	exports: {},
	parent: null,
	filename: '/Users/arius/Lib/node-test/modules.js',
	loaded: false,
	children: [],
	paths: [
	  '/Users/arius/Lib/node-test/node_modules',
	  '/Users/arius/Lib/node_modules',
	  '/Users/arius/node_modules',
	  '/Users/node_modules',
	  '/node_modules'
	]
      }
    #+end_src

**** 文件夹处理
     
     当找不到文件的时候，会在该路径查询文件夹。
     加载的 ~package.json~ 会以 ~{key: path, value: configJSON}~ ，
     的格式存到 ~packageJSONCache~ 。
     
     查询的实现在 ~lib/internal/modules/esm/resolve.js::packageMainResolve~ 中。

     顺序：
     1. 查询缓存
     2. 查询 ~package.json~ ，并缓存
	1. 如果有，先查询是否有 ~exports~ (2020-04 的更新)
	2. 再查询是否有 ~main~
     3. 找 ~index~
     4. 报错

*** 模块解析

    实现在 ~lib/internal/modules/cjs/loader.js::Module._compile~ 。
    当查询到后缀为 ~c?js~ 或者默认处理时，走 js 解析。
    可以把每个 js 文件简单理解成一个函数。
    因为这个原因，每次引用最外层的代码会被执行，但只是 ~exports~ 对应的模块。
    Node 解释器就是执行这个函数的人，将对应的参数传给它，保证执行的作用域。

    #+begin_src bash
      > node                                                   
      Welcome to Node.js v14.9.0.
      Type ".help" for more information.
      > require('module').wrapper
      Proxy [
	[
	  '(function (exports, require, module, __filename, __dirname) { ',
	  '\n});'
	],
	{ set: [Function: set], defineProperty: [Function: defineProperty] }
      ]
      > 
    #+end_src

    #+begin_src js
      function(
	exports, // 当前模块 exports 的引用，和 module.exports 是一个东西
	require,// 一般就是 Module.prototype.require 即 _Module.prototype.require._load
	module, // 当前模块, 也是 this
	__filename, // 文件绝对路径
	__dirname // 文件相对路径
      ) {}
    #+end_src

    通过前后增加函数执行的外壳，和 ~Module~ 统一管理输入的文件访问参数，
    生成一个匿名函数，抛给 VM 执行这串代码。
    也因为是函数方式来执行整个文件，可以直接打印看到整个模块的相关信息。

    #+begin_src js
      // args.js
      console.log(arguments)
      // run it
      node args.js  
      [Arguments] {
	'0': {},
	'1': [Function: require] {
	  resolve: [Function: resolve] { paths: [Function: paths] },
	  main: Module {
	    id: '.',
	    path: '/Users/arius/Lib/node-test/require-test',
	    exports: {},
	    parent: null,
	    filename: '/Users/arius/Lib/node-test/require-test/args.js',
	    loaded: false,
	    children: [],
	    paths: [Array]
	  },
	  extensions: [Object: null prototype] {
	    '.js': [Function (anonymous)],
	    '.json': [Function (anonymous)],
	    '.node': [Function (anonymous)]
	  },
	  cache: [Object: null prototype] {
	    '/Users/arius/Lib/node-test/require-test/args.js': [Module]
	  }
	},
	'2': Module {
	  id: '.',
	  path: '/Users/arius/Lib/node-test/require-test',
	  exports: {},
	  parent: null,
	  filename: '/Users/arius/Lib/node-test/require-test/args.js',
	  loaded: false,
	  children: [],
	  paths: [
	    '/Users/arius/Lib/node-test/require-test/node_modules',
	    '/Users/arius/Lib/node-test/node_modules',
	    '/Users/arius/Lib/node_modules',
	    '/Users/arius/node_modules',
	    '/Users/node_modules',
	    '/node_modules'
	  ]
	},
	'3': '/Users/arius/Lib/node-test/require-test/args.js',
	'4': '/Users/arius/Lib/node-test/require-test'
      }
    #+end_src

    因为是引用的关系 ~module.exports~ 一般和 ~exports~ 指向同一个东西,
    但需要注意，导出永远是 ~module~ 是不会变的， ~exports~ 只是引用。

    #+begin_src js
      module.exports = {
	a: '123', // 最终依然是 123
      }
      exports.a = '321';
    #+end_src
   
*** 依赖循环

    而当 ~require~ 一个包或者文件的时候，执行（或者说依赖）的并不直接是这个包。
    对应整个对象的 ~exports~ 和 ~module~ , 会被缓存一个全局对象 ~Module._cache[filename]~ 中。

    假如执行 ~a.js~ 。
    #+begin_src js
      // a.js
      const b = require('./b')
      console.log(b) // 'b'
      module.exports = 'a'
      // b.js
      const a = require('./a')
      console.log(a) // {}, Module._cache中 a依然是 空的 Module {} 对象
      module.exports = 'b'
    #+end_src

    依赖的处理中 CJS 和 ES 运行顺序是一致的 (~default~, 子模块都为 ~undefined~)，不同的是 ES 可以动态替换引用。
    只要引用是在加载完成之后被调用, 就不会有问题。
    所以需要注意需要最外层执行的函数的顺序。

    #+begin_src js
      // a.js
      import { b } from '../';
      console.log(b)
      export const a = 'a'
      // b.js
      import { a } from '../';
      console.log(a) // undefined

      export const callA = () => {
	console.log(a) // 'a'
      }

      export const b = 'b'
      // index
      export * from './a';
      export * from './b';
    #+end_src

    如果是 ~mjs~ 的话，会报错。。
    因为 esm 直接执行，是异步静态之行的

    #+begin_src js
      ReferenceError: Cannot access 'a' before initialization
    #+end_src
    
** 拓展 ECMAScript 模块

   #+begin_quote
   Node v13 开始本身支持 ECMASCript module。
   #+end_quote

   官方实验 ES6 规范，以 ~.mjs~ 后缀结尾。
   cjs 和 ejs 的区别分别是， ~require~ + ~module.exports~ 对应 ~import~ 和 ~export~ 。
   
   #+begin_src
   // 使用的时候会有一个 实验的 warning
   (node:55066) ExperimentalWarning: The ESM module loader is experimental.
   
   // 如果直接 import 调用对应不是 mjs 的模块
   (node:54924) Warning: To load an ES module, set "type": "module" in the package.json or use the .mjs extension.
   #+end_src

   node 要求 es6 模块都使用 ~.mjs~ 后缀，且 *默认启动严格模式* 。
   或者在 ~package.json~ 中制定为 ~type~ 为 ~module~ ，这样执行目录内 ~js~ 脚本都会解析成 ES6 模块。
   其他(非 ~js~ )使用 ~cjs~ 或者 ~ejs~ 会使用对应的解析方式。

   与 babel 时混用处理的方式不同， ~require~ 不能加载 ~mjs~, ~mjs~ 中不能使用 ~require~ 。

*** 相互调用

    ~cjs~ 调用 ~mjs~ 时，需要用异步。
    ~require()~ 不支持 ES6 模块的一个原因是，它是同步加载，而 ES6 模块内部可以使用顶层 ~await~ 命令，导致无法被同步加载。
    #+begin_src js
      (async () => {
	await import('./my-app.mjs');
      })();
    #+end_src

    而 ~mjs~ 调用 ~cjs~ 的时候只能整体调用，无法解析，作 shaking 啥的。

*** 支持多个模式

    如果是 ES6 模式则需要给一个整体的接口 ~export default~ 。

    如果是 CommonJS 模式则需要封装一层，拆分一个单独的文件。

    #+begin_src js
      import cjsModule from '../index.cjs';

      export const {...} = cjsModule;
    #+end_src

    或者使用 ~package.json~ 的形式修改, 其中 ~exports~ 除了相对路径替换外，还可以挑选调用方式。
    具体如下：

    #+begin_src js
      // ./index.js
      require('find-me');
      // ./index.mjs
      import 'find-me';
      // ./node_modules/find-me/package.json
      {
	"exports": {
	  "import": "./me.mjs"
	  "require": "./you.js"
	}
      }
      // ./node_modules/find-me/you.js
      console.log('Found you')
      // ./node_modules/find-me/me.mjs
      console.log('Found me!')
    #+end_src


