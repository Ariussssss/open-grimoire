#+STARTUP: all
#+SETUPFILE: ~/.emacs.d/org-styles/html/main.theme
#+TITLE: high-concurrency
#+DATE: [2023-03-08 23:08]
* Refers
* words
- QPS query per second 每秒查询数
- TPS Transaction Per Second 每秒事务数
- RT Response Time 响应时间
  - 网络, 逻辑, 数据库, 缓存, IO 等
* cache 缓存
- 让访问速度更快
- 二八定律, 处理经常读取的数据, 频繁查询的数据, 热点数据, I/O 瓶颈数据, 计算昂贵的数据等
- 符合 5 分钟法则和局部性原理的数据都可以用来缓存
- 预处理
** 分类
*** 本地
- 进程内存储, 语言标准库容器
- 一致性, 过期时间, 清空策略
*** 分布式
- 一致性 hash 算法
**** 常用组件
- Memcache
- Redis Cluster
** 更新策略
*** Cache-Aside
- set 的时候删除缓存
*** Cache-As-SoR  System Of Record 记录系统, 数据库
- 把缓存当数据源
- 缓存自己维护一致性
- 更新
  - Read Though 手动更新
  - Write Though 直写, 写入缓存, 同时写入数据源, 然后返回
  - Write Back 写入缓存,直接返回, 异步更新数据源
** 相关
- CPU L1, L2, L3, 实时系统, 大规模计算模拟, 图像处理领域常用
-  system-of-record (SOR)
* async 异步
- 拆分流程
- 后续步骤丢到队列里完成
* scale-out 横向扩展
- 程序支持分布式扩展, 然后堆机器
* pooling 池化

* message queue 消息队列
** 解耦
- 允许你独立的扩展或修改两边的处理过程
- 保留接口和应付需求的可能
** 冗余
- 把数据进行持久化直到它们已经被完全处理, 通过这一方式规避了数据丢失风险
- 需要你的处理系统明确的指出该消息已经被处理完毕, 从而确保你的数据被安全的保存直到你使用完毕
** 扩展性
因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。
** 灵活性 & 峰值处理能力
在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。
** 可恢复性
系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。
** 顺序保证
在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。Kafka 保证一个 Partition 内的消息的有序性。
** 缓冲
在任何重要的系统中，都会有需要不同的处理时间的元素。例如，加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行———写入队列的处理会尽可能的快速。该缓冲有助于控制和优化数据流经过系统的速度。
** 异步通信
很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。
* read/write-splitting 读写分离
- 主从库, 主库写入, 多从库完成读, 数据库内部完成数据同步
- 业务经常多读少写, 提高读性能瓶颈
- 作为最终优化方案, 有很高的研发和维护成本
** Problem
*** 连接池分离, 研发难度增加
对比缓存策略
*** 保证高可用性, 读连接池故障自动恢复
一般添加代理, 主流使用的 MySQL 代理有 ShardingJDBC、ProxySQL 以及 MyCat
*** 主从一致性
出现一致性问题
- 写操作后, 定义睡眠时间, 基本不用
- 搭建全同步集群, 写操作包含全从库同步流程
- 通过代理强制走主库
** Proxy
*** ProxySQL
- 通过 monitor 用户设置高权限定期执行健康检查, 重试 3 次
** 相关
*** MGR MySQL Group Replication 集群
