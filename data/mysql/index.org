#+STARTUP: all
#+SETUPFILE: ~/.emacs.d/org-styles/html/main.theme
#+TITLE: index
#+DATE: [2023-01-10 13:33]
* Refers
* Mysql
MySQL 数据库支持多种索引类型，如 BTree 索引，哈希索引，全文索引等等
大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构

** 带有顺序访问指针的 B+Tree
:PROPERTIES:
:CUSTOM_ID: 带有顺序访问指针的 btree
:END:
叶子节点带指针，提高区间访问性能

** why B+Tree
:PROPERTIES:
:CUSTOM_ID: why-btree
:END:
索引本身很大，以索引文件的形式存储在磁盘上 索引查找过程消耗磁盘 I/O
相比于内存存取，I/O 存取的消耗要高几个数量级

评价索引优劣，也就是查找过程中磁盘 I/O 操作次数的渐进复杂度

** 主存存储原理
:PROPERTIES:
:CUSTOM_ID: 主存存储原理
:END:
目前主要的计算机使用主存都是随机读写存储器 RAM

主存抽象来说是一个存储单元组成的矩阵，存储单元存储数据，有唯一地址。通过编址规则，定位到唯一的存储单元。

存储过程：（写类似）

1. 系统读取时，将地址信号放在地址总线上传给主存
2. 主存接到信号，解析信号定位到存储单元
3. 存储单元数据放到地址总线，供其他部件读取

主存存取时间和次数呈线性关系，无机械操作，两次存取数据对时间无影响

** 磁盘存取原理
:PROPERTIES:
:CUSTOM_ID: 磁盘存取原理
:END:
与主存不同，磁盘 I/O 存在机械运动消耗

磁盘转动，磁盘头不转动 每个同心环叫做磁道 半径相同的磁道组成一个柱面
磁道被半径划分成一个个扇区 扇区是磁盘的最小存储单元

存储过程：

1. 当磁盘读取数据时，系统将逻辑地址传给磁盘
2. 磁盘的控制电路，按照寻址逻辑，将逻辑地址翻译成物理地址，确定磁道和扇区
3. 为了读取这个扇区，需要移动磁盘，对准磁道，即寻道，耗费寻道时间
4. 然后将磁盘旋转到目标扇区，耗费旋转时间
5. 读取数据，返回

由于存储介质，磁盘存储本身比主存满很多，再加上机械运动耗费，存取速度时主存的几百分之一

** 局部性理论和磁盘预读
:PROPERTIES:
:CUSTOM_ID: 局部性理论和磁盘预读
:END:
因此为了提高效率，减少磁盘 I/O
磁盘会预读，即使是请求一个字节，也会按顺序预读一定长度到内存

理论为局部性理论

程序运行的数据通常集中 磁盘顺序效率高

预读长度一般为 page 的整数倍 page 是计算机管理储存器的逻辑块
硬件和操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个块为 1 页，通常为 4k
主存和磁盘通过页为单位交换数据

过程

1. 系统请求的数据不在主存时，向磁盘发起缺页异常
2. 磁盘找到数据的起始位置
3. 连续读取一页或者多页
4. 返回，数据载入主存，程序继续执行

** B+树性能分析
:PROPERTIES:
:CUSTOM_ID: b 树性能分析
:END:
一般使用磁盘 I/O 次数评价索引结构的优劣

B-Tree 检索一次最多访问 h 个节点 数据库系统设计者利用磁盘预读原理
一个节点大小设为一个页，每个节点可以通过一次 I/O 完全载入

每次新建节点，直接申请一个页的空间，保证物理存储在一个页

B-Tree 中一次检索最多需要 h-1 次 I/O（根节点常驻内存），渐进复杂度为 O(h)=O(logdN)。一般实际应用中，出度 d 是非常大的数字，通常超过 100，因此 h 非常小（通常不超过 3）。

出度为节点枝叶

相比红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的 I/O 渐进复杂度也为 O(h)，效率明显比 B-Tree 差很多。

* MYSQL 索引
:PROPERTIES:
:CUSTOM_ID: mysql 索引
:END:
myisam 和 innodb
** 聚簇索引 Clustered Index
- 是一种数据存储方式, InnoDB 中 B+树按顺序存储所有数据, 每个索引对应一个树
- 默认主建, InnoDB, 索引不压缩
*** 优势
- 访问快, 数据和索引存一起
- 排序查找和范围查找速度快
*** 劣势
- 依赖插入顺序, 非递增主键存在时, 数据插入会引起页裂, 一般用自增
- 更新主键代价高, 导致行移动
- 二级索引也需要搜索主键
** 二级索引 Secondary Index
- 通过一个二级索引, 找到一个主键索引, 再找到正行数据(回表查询)
- MyISAM
** MyISAM
:PROPERTIES:
:CUSTOM_ID: myisam
:END:
索引文件仅仅保存数据记录的地址

使用的 B+Tree 作为索引，叶子结点 data 域存放数据记录的地址

主索引和辅助索引结构上没有区别

非聚集

MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快

MyISAM 支持全文索引，查询效率高

** InnoDB
:PROPERTIES:
:CUSTOM_ID: innodb
:END:
聚集索引，但也是 B+Tree 要求表必须有主键，如果没有显式指定
mysql 系统会自动选择一个可以唯一标识数据记录的列作为主键
如果不存在这种列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，这个字段长度为 6 个字节，类型为长整

主键搜索高效，辅助检索需要检索两遍索引

InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描

InnoDB 支持事务，MyISAM 不支持，对于 InnoDB 每一条 SQL 语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条 SQL 语言放在 begin 和 commit 之间，组成一个事务；

InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；

Innodb 不支持全文索引

区别

- 数据文件就是索引文件 InnoDB 的叶节点 data 域保存了完整的数据记录
  索引的 key 是数据的主键 数据文件本身就是主索引
- InnoDB 的辅助索引 data 存储相应记录的主键的值而不是地址
  辅助索引通过引用主键进行索引

不建议过长字段做主键，因以所有辅助所以都引用主索引
非单调字段做主键不好，B+Tree 非单调主键会造成插入新纪录时，为了维持树而频繁分裂调整，低效。用自增较好。

*如何选择：*

1. 是否要支持事务，如果要请选择 innodb，如果不需要可以考虑 MyISAM；

2. 如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果既有读写也挺频繁，请使用 InnoDB。

3. 系统奔溃后，MyISAM 恢复起来更困难，能否接受；

4. MySQL5.5 版本开始 Innodb 已经成为 Mysql 的默认引擎(之前是 MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用 InnoDB，至少不会差。

** 优化 index
:PROPERTIES:
:CUSTOM_ID: 优化 index
:END:
mysql 的 sql 优化器在多索引时行为比较复杂

#+begin_src sql
  // 查看当前数据库index
    mysql> show index from Khala.User;
  +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
    +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    | User  |          0 | PRIMARY  |            1 | id          | A         |           3 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
    | User  |          0 | name     |            1 | name        | A         |           3 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
    +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    2 rows in set (0.05 sec)    
#+end_src

可以通过=explain=来分析索引的行为

type：

- ref 多值匹配
- range 范围搜索
- all 全文搜索

*** 全列匹配
:PROPERTIES:
:CUSTOM_ID: 全列匹配
:END:
通过对多列进行精确匹配（=，in）索引会被使用 索引顺序敏感
mysql 查询优化器会自动调整条件顺序，使用适当的索引

*** 最左前缀匹配
:PROPERTIES:
:CUSTOM_ID: 最左前缀匹配
:END:
查询条件精确匹配一个或多个 索引会被用到
比如比如<a,b,c>，匹配 a，ab，abc 所以会生效

*** 查询条件用到了索引中列的精确匹配，但是中间某个条件未提供
:PROPERTIES:
:CUSTOM_ID: 查询条件用到了索引中列的精确匹配但是中间某个条件未提供
:END:
比如索引<a,b,c>精确搜索 ac 由于索引对顺序敏感，没有 b 就无法对 c 进行索引
需要从结果进行扫描过滤 可以通过辅助索引<a,c>让 ac 精确搜索中的 c 索引生效

或者通过填坑的方式 精确搜索 ac，b in 所有 b
在 b 值少的情况下，对多索引有效率提升

*** 查询条件没有指定索引第一列
:PROPERTIES:
:CUSTOM_ID: 查询条件没有指定索引第一列
:END:
不会用到索引

*** 匹配某列的前缀字符串
:PROPERTIES:
:CUSTOM_ID: 匹配某列的前缀字符串
:END:
like %在开头

*** 范围查询
:PROPERTIES:
:CUSTOM_ID: 范围查询
:END:
范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引

索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引

注意=between=是相当于=in=操作，属于精确搜索

explain 无法分辨范围索引和多值匹配，都是 range

*** 查询条件中含有函数或表达式
:PROPERTIES:
:CUSTOM_ID: 查询条件中含有函数或表达式
:END:
任何函数或者表达式，都不会触发索引

* 索引选择性与前缀索引
:PROPERTIES:
:CUSTOM_ID: 索引选择性与前缀索引
:END:
对比

#+begin_src sql
  SHOW PROFILES;
#+end_src

选择性就是不重复的索引值占总记录数比值

#+begin_src sql
  SELECT count(DISTINCT(first_name))/count(*) AS Selectivity FROM table;
#+end_src

兼顾长度和选择性 可以选择前几位

#+begin_src sql
  ALTER TABLE employees.employees
    ADD INDEX `first_name_last_name4` (first_name, last_name(4));
#+end_src

* InnoDB 的主键选择与插入优化
:PROPERTIES:
:CUSTOM_ID: innodb 的主键选择与插入优化
:END:
在使用 InnoDB 存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。

InnoDB 模式，mysql 会形成连续的地址，根据主键顺序进行索引分页存放，是紧凑结构，顺序填满

连续的自增索引会使得新纪录不需要移动旧数据
不需要因频繁移动而产生大量碎片

http://blog.codinglabs.org/articles/theory-of-mysql-index.html
